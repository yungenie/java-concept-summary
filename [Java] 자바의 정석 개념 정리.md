# Java의 정석 - 학습 내용 정리
_Assembled by yunjin (2022-05-27)_

</br>

## 📍 책 소개

<img src="https://storage.googleapis.com/static.fastcampus.co.kr/prod/uploads/202109/104011-472/group-1799.png" width="300">

처음부터 끝까지 상세하게 알려주신다. 자바 기본 문법을 충실하게 공부해서 기초 주축을 준비하는데 좋은 책 입니다.

:information_desk_person: 책을 읽으면서 중요하다고 생각되는 내용 위주로 작성한 정리본입니다.  

<br/>

## 📍 간단한 리뷰 코너

- 별점 : ★★★★☆
- 리뷰 : 단월별 구성이 잘되어 있고, 자바 기본 문법부터 객체지향 프로그램, 컬렉션 프레임 워크, 람다까지 기본적인 지식을 공부할 수 있어서 좋았습니다.

<br/> 
 
## 📍 정리

#### [ch1]  
    - 파이썬 91년, 자바 96년
    - 자바8부터 함수형 기능 추가.  
    - JDK : 자바 개발도구  
    - 원래는 3년마다 버전 Update.   
    - 자바8부터 6개월마다 버전 Update  
 
#### [ch1]  자바특징  
    - 프로그래밍 언어 + 객체지향 개념.  
      객치지향 언어 : C++, java,Python, js  
      ※ Python : 접근성은 좋지만, 객체지향 개념을 깊이 다루기에 어렵다.  
    
    - 자동 메모리 관리.  
      가비지 컬렉터 GC 메모리 자동 정리해줌. (프로그래머가 일일이 정리하지 않아도 된다.)  
    
    - 멀티 쓰레드 지원  
       하나의 프로그램에서 동시에 여러 작업을 하게 해줌.  
    
    - 풍부한 라이브러리로 쉽게 개발가능.  
    
    - 운영체제에 독립적  
      여러 운영체제에서 사용 가능.  

#### [ch1]  자바 가상 머신 (JVM)   
    - Macintosh : mac(맥)  
    - jvm만 설치되어 있으면 한번 작성. 운영체제 관계없이 어디서든 실행 가능.  
    - write once, run anywhere  

#### [ch2] 기본형과 참조형
    ● 값의 타입
    값 - 문자 (한글, 영문 등등) - char

       - 숫자  - 정수 (음수, 양수) - byte, short, int, long

              - 실수 (소수점) - float, double

       - 논리 (참, 거짓) - boolean

    - Java에서는 값의 종류에 따라 8개의 데이터 타입을 정의함.
    - 8개의 데이터 타입을 기본형 이라고 합니다. (데이터의 가장 기본이 되는 타입)
    - 저장하고자 하는 값의 크기와 용도에 따라 선택하여 사용합니다.
    - 변수를 선언 할 때는 변수에 저장할 값을 가장 적합한 데이터 타입을 정해서 변수를 선언하면 됩니다.
    - 메서드를 선언할 때 리턴타입이 존재한다면 적합한 데이터 타입으로 정의하면 됩니다.


    ● 기본형 (primitive type)
    - 오직 8개 (boolean, char, byte, short, int, long, float, double)
    - 논리형, 문자형, 숫자형, 실수형 총 4가지 종류이다.
    - 논리형 - boolean : 1byte (1byte = 8bit) 1bit 2진수 한자리
    - 문자형 - char : 2byte (유니코드)
    - 숫자형 - byte : 1byte, short : 2byte, int : 4byte, long : 8byte (숫자형 default type ⇒ int)
    - 실수형 - float : 4byte (부동소수점), double : 8byte(float보다 정밀도 2배) (실수형 default type ⇒ double)
      ※ 정밀도 : 오차 없는 자리수
      ex) 3.4 x 10 38승
      s | E() | M
      s : 부호
      E :  지수 → 38
      M : 가수 → 3.4


    ● 참조형 (reference type)
    - 기본형을 제외한 나머지 (String, System 등)
    - 무한개
    - 메모리 주소를 저장 (4byte 또는 8 byte)
    - 32bit JVM : 4byte 40억 (4GB)
    - 64bit JVM : 8byte 40억 x 40억 160경 바이트 (1600만 테라바이트)
    
    ● 기본형 표현범위
    8bit = 1byte
    1bit ⇒ 0,1 둘 중 하나의 값. 2진수 한자리
    n비트로 표현할 수 있는 값의 개수 : 2n승 개

#### 컴퓨터 기억용량 단위
    1byte = 8bit (바이트)
    1KB = 1,024 byte (킬로바이트)
    1MB = 1,024 KB (메가바이트)
    1GB = 1,024 MB (기가바이트)
    1TB = 1,024 GB (테라바이트)
    1PB = 1,024 TB (페타바이트)
    1EB = 1,024 PB (엑시바이트)
    1ZB = 1,024 1EB (제타바이트)
    1YB = 1,024 1ZB (요타바이트)


#### 기억(저장)용량의 단위 상세
> - RAM, HDD, VGA card, Cache, Buffer의 단위로 사용
> 
> | **이름** | 기호  | 2진 기준| 값|                                     
> |:----|:-----|:--------------------------------------|---------------------------------------:|
> | kilo byte | KB  | 2<sup>10</sup> Byte| 1,024 Byte| 
> | mega byte | MB  | 2<sup>20</sup> Byte| 1,048,576 Byte|                        
> | giga byte | GB  | 2<sup>30</sup> Byte| 1,073,741,824 Byte|                    
> | tera byte | TB  | 2<sup>40</sup> Byte| 1,099,511,627,776 Byte|                
> | peta byte | PB  | 2<sup>50</sup> Byte| 1,125,899,906,842,624 Byte|            
> | exa byte | EB  | 2<sup>60</sup> Byte| 1,152,921,504,606,846,976 Byte|         
> | zetta byte | ZB  | 2<sup>70</sup> Byte| 1,180,591,620,717,411,303,424 Byte| 
> | yotta byte | YB  | 2<sup>80</sup> Byte| 1,208,925,819,614,629,174,706,176 Byte|
>
> - RAM 용량 (사람은 MB, GB 단위 사용, 컴퓨터는 KB 단위를 사용) <p>
>   512MB = 512 x 1,024KB = 524,288 KB<p>
>   1GB = 1,024 x 1,024KB = 1,048,576 KB<p>
>   4GB = 4 x 1,024 x 1,024KB = 4,194,304 KB<p>
>
> 
> - HDD 용량 (사람은 GB, TB 단위 사용, 컴퓨터는 MB 단위를 사용)
>   10GB = 10 x 1,024MB = 10,240 MB<p>
>   500GB = 500 x 1,024MB = 512,000 MB<p>
>   1TB =  1,024 x 1,024MB = 1,048,576 MB<p>

#### [ch2-07~08]  
    - char '' 홑 따옴표 안에 하나의 문자값 존재해야한다.
    - 문자열 결합은 왼쪽에서 오른쪽으로 진행되기 때문에 순서에 따라 전혀 다른 결과가 나올 수도 있다.

#### [ch6-14~16]  
    - 객체는 변수 묶어 놓은 것.
    - 지역변수 : 메서드 내에 선언된 변수 (메서드의 매개변수 또한 지역변수이다!)
    - 인스턴스 변수(전역변수/객체변수), 클래스 변수(전역변수/Static 변수), 지역변수

#### 선언 위치에 따른 변수
    - 객체는 속성과 기능이 있다.
    - 클래스는 멤버변수와 메서드가 있음.
    - 멤버 변수는 데이터를 담는 그릇이라 표현하고, 속성이라 부르기도 한다.
    - 공통속성, 개별속성 2가지로 존재한다.
    - 공통속성은 클래스변수(static 변수 혹은 전역변수) 1가지 종류가 있다.
    - 개별속성 인스턴스 변수(객체변수 혹은 전역변수), 메소드 변수(지역변수) 2가지 종류로 분류된다.

#### [ch6-29] 메서드 간의 호출과 참조    
    - static 메소드란 : 객체생성없이 호출 가능한 메서드. 언제나 사용가능.  
    - static 메소드를 붙일지 말지 결정? 여러 클래스에서 공통으로 사용할 때 (공통속성)으로 사용하기 위해서   
    - static 메소드는 인스턴스 변수 사용 불가.   
      왜? 객체생성을 하지않고 인스턴스 변수 사용할 수 없다. (객체 생성 후 호출 가능하기때문에.)  
    ※ static 메소드가 인스턴스 메소드 호출 안됨.  
    iv : 인스턴스 변수 (개별속성)  
    cv : 클래스 변수 (공통속성)  
    객체는 iv 변수의 묶음이다.  

#### [ch6] 생성자    
    모든 클래스는 1개 이상의 생성자를 가져야 한다.  
    -> 생성자가 하나도 없을 때 컴파일러가 기본생성자 자동추가함.  

#### [ch6] 생성자this()  
    생성자에서 다른 생성자 호출할 때 사용  
    다른 생성자 호출 시 첫 줄에서만 사용가능.  

#### [ch6]참조변수 this  
    지역변수와 인스턴스변수를 구별할때 사용.  
    멤버변수(인스턴스변수, static 변수)는 자동 초기화되고, 지역변수는 수동 초기화 해야함.  

#### [ch7] 
    명시적 초기화해서 대입이 된다.   
    Class a = new Class() // 참조변수의 초기화  
    1. Class a 초기화 되고  
    2. 객체가 만들어지면서 멤버변수 값들이 대입이 된다.  
    Class a -> 초기화 아님. 저장 공간 안만들어졌음.  

#### [ch7] 객체지향개념  
    단일상속 : 하나의 부모만 상속을 허용한다.  

#### [ch7] Object클래스  
    부모가 없는 클래스는 자동적으로  Object클래스를 상속받게 된다.  

#### [ch7] toString()  
    클래스명@객체의 주소값(정확하게는 주소값은 아니다)  

#### [ch7] 오버로딩 라이딩.    
    오버로딩 : 메소드명은 동일하고 매개변수가 다른 것.  
    오버라이딩 : 메소드명, 매개변수 동일하고 내용을 재정의 하는 것.  
    
    오버로딩 : 동일한 메서드를 여러개 가질 수 있는 걸 말합니다. 단, 메서드 매개변수 숫자/타입이 다릅니다.  
    오버라이딩 : 부모클래서에서 상속받은 메서드를 재정의하는 것 

#### [ch7] 오버라이딩 조건  
    1. 선언부가 조상 클래스의 메서드와 일치해야 한다.  
    2. 접근 제어자가를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.  
    public,protected, private  
    3. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.  

    this : lv와 iv 구별에 사용.  
    super : 조상멤버과 자신멤버 구별할 때 사용.   

#### [ch7] 상속 : 생성자, 초기화블럭 상속 x  
    super() 호출해서 조상 생성자는 조상클래스가 초기화하게 하는 것.  
    자식클래스에서 조상 생성자를 호출할때 super를 쓴다.  
    
    조상이 선언한 멤버들을 초기화 할때 자식이 할게 아니라  
    자식클래스에서 조상생성자를 호출해서 조상의 클래스가 초기화 하도록 한다.  

#### [ch7] super() - 조상의 생성자  
    생성자 첫 줄에 반드시 생성자를 호출해야 한다.  
    그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입.  
    
    모든 생성자는 첫 줄에 다른 생성자를 호출해야한다.   
    그렇지 않으면 컴파일러가 자동 super();를 삽입한다.  
    
    기본 생성자 작성은 필수다!  

#### [ch7] import문 선언  
    이름이 같은 클래스가 속한 두 패키지를 import할 때는  
    클래스 앞에 패키지명을 붙여줘야 한다.  

#### [ch7] static import문  
    static멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.  
    -> 웬만하면 쓰지 않는게 좋다. 클래스 이름이 있으면 명확하게 알아보기 좋다.  

#### [ch7] 제어자  
    ● 접근 제한자 : public > protected> default > private (총4개)  
    ● 그 외 : static, final, abstract
    * public 안쓰면 default로 써야함.
    * 접근 제어자는 제일 왼쪽, 1개만 쓸 수 있다.
    * 클래스는 public, (default) 접근 제어자만 가능하다

#### [ch7] static 변수와 메서드
    ● static 변수(멤버변수)
        - 클래스가 메모리에 로드될 때 생성된다.
        - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
        - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
    ● static 메서드
        - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
        - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.
        - static 변수의 복잡한 초기화 수행

#### [ch7] final 접근제어자 (노변경)
    ● final 클래스
        - 변경될 수 없는 클래스
        - 확장될 수 없는 클래스 (final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.)
    ● final 메서드
        - 변경될 수 없는 메서드
        - 재정의 될 수 없는 메서드 (final로 지정된 메서드는 오버라이딩을 통해 재정의 할 수 없다.)
    ● final 변수
        - 멤버변수(클래스, 인스턴스), 지역변수 앞에 final 붙으면, 값을 변경할 수 없는 상수가 된다.

#### [ch7] abstract 접근제어자 (미완성)
    ● abstract 클래스
        - 클래스 내에 추상 메서드가 선언되어 있음을 의미
        - 추상 메서드가 포함한 클래스
        - 추상 클래스는 인스턴스(객체) 생성 불가
        - 추상 클래스를 상속받아 완전한 클래스로 만든 후에 객체 생성 가능
    ● abstract 메서드
        - 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드이다.
    
#### [ch7] 클래스내 static 초기화 블럭 
    static {} // 클래스 초기화 블럭  
    -> static 변수의 복잡한 초기화 수행.  

#### [ch7] 접근 제어자 (접근 범위)   
    public > protected> default > private (총4개)  
    접근제한 없음 > 같은 패키지 + 자손(다른 패키지) > 같은 패키지 > 같은 클래스  

#### 캡슐화와 접근 제어자
    - 접근 제어자를 사용하는 이유?
    - 외부로부터 데이터를 보호하기 위해서
        - ex) 접근 제어자를 private 하여 외부에서 직접 접근하지 못하도록 하고, 함수를 구현하여 간접접근 허용하게 만든다.
    - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

#### 추상클래스 (abstract class)
    - 추상 메서드를 갖고 있는 클래스 (미완성의 설계도)
        추상 메서드만 갖고 있는 게 아님. 일반 클래스의 구성 + 추상메서드를 추가로 갖고 있는 것
    - 상속을 통해 추상 메서드를 완성해야 인스턴스 생성 가능
    - 추상메서드 : 메서드에 선언부만 있고 구현부는 없는 abstract 제어자가 붙은 메서드

#### 추상클래스 장점
    - 여러 클래스에 공통부분을 뽑아서 만듬
    - 다른 클래스 작성에 도움을 주기 위한 것
    - 자손마다 다르게 구현될 것으로 예상되는 경우
    - 변경에 유리

#### 추상클래스  상속
    - 상속받은 추상메서드 모두 Override 해야함. 안하면 오류남
    - Class cannot extend multiple classes

#### 인터페이스(interface)
    - 추상메서드의 집합 (부수적 : static메서드 몸통포함, default 메서드 몸통포함, 상수 포함)
    - 멤버 변수를 가질 수 없음
    - 모든 멤버가 public
    - public static final 타입 상수명 = 값;
    - public abstract 메서드 이름 ();

#### 인터페이스 상속   
    - 인터페이스의 상속은 인터페이스 타입인 조상만 상속 받을 수 있음
    - 다중 상속이 가능 (추상메서드 충돌해도 문제없음)
        - 왜? 선언부라서 상관없음
    - public interface Child extends Parents, Grandparents

#### 인터페이스 구현
    - class 클래스 이름 implements 인터페이스명
    - 인터페이스에 정의된 추상메서드를 모두 구현해야 함
    - 단, 일부만 구현하는 경우 클래스 앞에 abstract 붙여야 함 (추상 메서드를 갖고 잇음)

#### extends vs implements
    - 일반 클래스, 추상 클래스, 인터페이스의 상속 모두 extends
    - 인터페이스의 상속 후 구현은 implements

#### [ch7] 인터페이스 장점  
    - 표준화 가능  
    - 변경에 유리한 유연한 설계 가능  
    - 선언(설계)와 구현을 분리시킬 수 있게 한다.  
    - 구현한 클래스가 변경되어도 선언(조상)은 안바꿀 수 있게 된다. (느슨한 결합)   
    - 서로 관계없는 클래스들을 관계를 맺어줄 수 있다.  

#### [ch7] 인터페이스 구현
    인터페이스를 구현한 것만 매개변수로 가능

#### 추상 클래스와 인터페이스의 차이?
    - 인터페이스는 모든 멤버가 public이며 멤버변수가 상수만 허용가능, 추상 클래스는 모든 접근 제어자 허용
    - 인터페이스는 다중상속 가능하나 추상 클래스는 다중상속 불가능
    - 인터페이스는 디폴트 생성자, static 메서드를 제외하곤 추상메서드만 가능하지만, 추상 클래스는 일반 메서드 구현도 가능
    - 인터페이스는 설계와 구현을 불리해 변경에 유리한 유연함 가짐, 추상 클래스는 확장성에 용이
    
#### [ch8] 예외처리
    프로그램 오류 
    - 컴파일에러(compile-time error) : 컴파일 할 때 발생하는 에러 (구문 및 문법 오류, 대표적으로 Syntax error, {} () '' "" 짝이 안맞을 때 등등)  
    - 런타임에러(runtime error) : 실행 할 때 발생하는 에러 (잘못된 개발설계로 대표적인 NullpointException, CastException, 무한루프, 0/0 등등)  
    - 논리적에러(logical error) : 작성 의도와 다르게 동작 (로직 오류로 인한 잘못된 계산)  
    
    런타임에러
    - Error : 심각한 에러
    - Exception : 미약한 에러
        - Exception 처리
        - RunTimeException 처리

#### [ch9-25] 래퍼클래스
    기본형의 값을 감싸는 클래스
    * 8개의 기본형을 객체로 다뤄야 할 때
    * 래퍼클래스 성능문제로 기본형 8가지가 나옴

#### [ch9-27] Number 클래스
    모든 숫자 래퍼클래스의 조상  (8개 기본형을 감싸는 클래스)
    Number 클래스는 기본형Value() 추상메소드를 가지고 있음.
    -> 래퍼 객체의 값을 기본형으로 바꿔주는 메소드들을 갖고 있음 

#### [ch9-28] 오토박싱 vs 언박싱  
    기본형 <-> 래퍼클래스         
    - 오토박싱 : 기본형 -> 래퍼클래스  
    - 언박싱 : 래퍼클래스 -> 기본형  
    
    * 문자열 -> 기본형  
    래퍼클래스.parse래퍼클래스()  
    
    * 문자열 -> 래퍼클래스  
    래퍼클래스.valueOf(문자열)  
 
#### [ch11] 컬렉션프레임워크(collections framework) 
     * 컬렉션(collection)  
     여러 객체(데이터)를 모아 놓은 것을 의미  
     
     * 프레임워크(framework) 
     프로그램을 만들 때 정해진 틀
     표준화, 정형화된 체계적인 프로그래밍 방식
     프레임워크를 사용하면 생산성이 올라가고 유지보수에 용이합니다
     ※ lib : 기능
     
     * 컬렉션프레임워크(collections framework)
     다수의 데이터를 다루기 위해 존재
     컬렉션을 다루기 위한 표준화된 프로그래밍 방식 
     컬렉션을 쉽게 편리하게 다룰 수 있는 다양한 클래스 제공  
     java.util 패키지에 포함. jdk1.2부터 제공  
     ※ 객체를 다룬다는 것은 객체를 저장,삭제,검색, 정렬을 하는 것을 의미한다. 
     ※ 다루는 데이터의 특징에 맞는 클래스를 선택해서 사용하면 된다! 
     
     * 컬렉션 클래스 
     다수의 데이터를 저장할 수 있는 클래스 (ArrayList/vector, HashSet) 
     
     * vector -> ArrayList의 old버전 대신 동기화 됨. ArrayList에도 동기화가 처리가능하도록 추가되었다? 
     
#### [ch11] List, Set, Map 간단 정리 
     * 데이터를 다루기 위한 인터페이스는 크게 3가지 존재합니다. 
     List, Set, Map 이고, 
     
     List : 순서 O, 중복 O 
     Set : 순서 X, 중복 X 
     Map : 순서 X, Key-중복 X, Value-중복 O 
     
     구현 클래스의 명칭에 3가지가 포함되어 있다면 
     상위 3가지를 구현한 클래스 입니다. 
     
     또한, List와 Set은 반대의 성격이나 공통된 부분을 모아 Collection이라고 부릅니다. 
     Map의 경우는 Key와 Value 쌍으로 이루어진 데이터 집합니다. 
     
     
#### [ch11] List
    1.LinkedList (연결리스트)
    @ 데이터 접근성이 나쁘다
    - next 다음요소만 안다
    - 뒤에 요소 모른다
    - 한번에 두세개 요소 건너뛰지 못함

    2.Doubly LinkedList (이중 연결리스트)
    @앞뒤 이동 접근성 향상
    - next, previous 다음 이전 요소 안다
    - 여전히 한번에 두세개 요소 건너뛰는 게 안됨

    3.Doubly Circle LinkedList (이중 원형 연결리스트)
    @ 맨앞, 맨뒤 요소 접근성 향상
    - 맨앞,맨뒤 요소 연결
    - 실제로 자바에서는 이중 연결리스트로 구현되어 있다.
    - 여전히 배열보다 접근성이 나쁘다는 단점을 가지고 있다.

#### [ch11] STACK VS QUEUE
    STACK
    클래스 
    QUEUE
    큐는 인터페이스로 큐 객체 선언할때 큐로 구현한 구현체로 선언해야함.

#### [ch12-1] 제네릭스 generics
    제네릭스란?
    - 개념 : 컴파일시 타입을 체크해주는 기능. 타입 체크 강화
    - 요약 : 컴파일러에게 타입정보를 전달하여 타입을 체크하여 형변환 에러를 줄이기 위함.
    - 정리 : RuntimeError 에서 CompileError 체크할 수 있게 CompileError level로 끌어온 것이 제네릭스
    - 장점 :  컴파일 타임에서 타입 체크 강화하여 타입의 안정성을 높히고 형변환 번거로움이 줄어 코드가 간결해진다.
    
    초기화
    - String str = null; < String str = "";
    - Object[] objArr = null; < Object[] objArr = Object[0]; or {};
    - NullPointerException 발생 줄이기 위해서
    
    타입변수
    - Object타입 대신 타입변수 (E)를 선언해서 사용.
    - <E> element의 의미일 때 쓰고 보통 <T>를 주로 쓴다.
    
    제네릭스 타입변수 객체의 다형성
    - 타입변수<E> 대신, 실제 타입<객체>을 지정(대입)
    - ↑ 타입변수 대신, 실제 타입을 지정하면 형변환 생략가능

    클래스든, 메서드든 제네릭 참조변수가 선언되어 있으면 재네릭 클래스/메서드가 된다.
    
    와일드카드?
    와일드카드가 안될 때 제네릭 메서드 쓰는 경우가 많다.

#### [ch12 4~6] 제네릭스 용어, 제네릭 타입과 다형성
    - Class Box<T> 
        → Box<T> : 제네릭스 클래스
        → Box : 원시타입
        → T : 타입변수 T선언
    
    - Box<String> b = new Box<String>();
        → 타입변수에 실제 타입 대입
        → 매개변수화된 타입 (대입된 타입이라고 함. parameterized type)

    - 제네릭 타입과 다형성
        → 제네릭 클래스간의 다형성은 성립
        → 매개변수의 다형성도 성립
        → 참조변수와 생성자의 대입된 타입은 일치해야함
            ex)ArrayList<String> list = new ArrayList<String>();

    - 여러 개의 타입 변수가 필요한 경우 콤마(,)를 구분자로 선언
    - 생성자에 타입지정 생략가능.

#### [람다1] T
    클래스 밖에 있는 걸 함수라 부른다.
    자바에서는 클래스 밖에 있을 수 없기 때문에 전부다 메서드이다.
    람다 사용할 때 무조건 인터페이스 작성해야하는 지?
    함수형 인터페이스 -> @ 애너테이션 쓰기


#### [ch14] 람다와 스트림
    - 함수와 메서드 차이?    
     근본적으로 동일. 함수는 일반적 용어. 메서드는 객체지향개념 용어  
     함수는 클래스의 독립적, 메서드는 클래스에 종속적  
     -> 함수는 클래스 외부, 메서드는 클래스 내부. 클래스 밖에 있는 걸 함수라고 부른다. 자바에서 클래스는 밖에 있을 수 없기 때문에 전부 메서드이다.  

