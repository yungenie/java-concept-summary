# Java의 정석 - 학습 내용 정리
_Assembled by yunjin (2022-05-27)_

</br>

## 📍 책 소개

<img src="https://storage.googleapis.com/static.fastcampus.co.kr/prod/uploads/202109/104011-472/group-1799.png" width="300">

처음부터 끝까지 상세하게 알려주신다. 자바 기본 문법을 충실하게 공부해서 기초 주축을 준비하는데 좋은 책 입니다.

:information_desk_person: 책을 읽으면서 중요하다고 생각되는 내용 위주로 작성한 정리본입니다.  

<br/>

## 📍 간단한 리뷰 코너

- 별점 : ★★★★☆
- 리뷰 : 단월별 구성이 잘되어 있고, 자바 기본 문법부터 객체지향 프로그램, 컬렉션 프레임 워크, 람다까지 기본적인 지식을 공부할 수 있어서 좋았습니다.

<br/> 
 
## 📍 정리

#### [ch1]  
    - 파이썬 91년, 자바 96년
    - 자바8부터 함수형 기능 추가.  
    - JDK : 자바 개발도구  
    - 원래는 3년마다 버전 Update.   
    - 자바8부터 6개월마다 버전 Update  
 
#### [ch1]  자바특징  
    - 프로그래밍 언어 + 객체지향 개념.  
      객치지향 언어 : C++, java,Python, js  
      ※ Python : 접근성은 좋지만, 객체지향 개념을 깊이 다루기에 어렵다.  
    
    - 자동 메모리 관리.  
      가비지 컬렉터 GC 메모리 자동 정리해줌. (프로그래머가 일일이 정리하지 않아도 된다.)  
    
    - 멀티 쓰레드 지원  
       하나의 프로그램에서 동시에 여러 작업을 하게 해줌.  
    
    - 풍부한 라이브러리로 쉽게 개발가능.  
    
    - 운영체제에 독립적  
      여러 운영체제에서 사용 가능.  

#### [ch1]  자바 가상 머신 (JVM)   
    - Macintosh : mac(맥)  
    - jvm만 설치되어 있으면 한번 작성. 운영체제 관계없이 어디서든 실행 가능.  
    - write once, run anywhere  

#### [ch2] 기본형과 참조형
    ● 값의 타입
    값 - 문자 (한글, 영문 등등) - char

       - 숫자  - 정수 (음수, 양수) - byte, short, int, long

              - 실수 (소수점) - float, double

       - 논리 (참, 거짓) - boolean

    - Java에서는 값의 종류에 따라 8개의 데이터 타입을 정의함.
    - 8개의 데이터 타입을 기본형 이라고 합니다. (데이터의 가장 기본이 되는 타입)
    - 저장하고자 하는 값의 크기와 용도에 따라 선택하여 사용합니다.
    - 변수를 선언 할 때는 변수에 저장할 값을 가장 적합한 데이터 타입을 정해서 변수를 선언하면 됩니다.
    - 메서드를 선언할 때 리턴타입이 존재한다면 적합한 데이터 타입으로 정의하면 됩니다.


    ● 기본형 (primitive type)
    - 오직 8개 (boolean, char, byte, short, int, long, float, double)
    - 논리형, 문자형, 숫자형, 실수형 총 4가지 종류이다.
    - 논리형 - boolean : 1byte (1byte = 8bit) 1bit 2진수 한자리
    - 문자형 - char : 2byte (유니코드)
    - 숫자형 - byte : 1byte, short : 2byte, int : 4byte, long : 8byte (숫자형 default type ⇒ int)
    - 실수형 - float : 4byte (부동소수점), double : 8byte(float보다 정밀도 2배) (실수형 default type ⇒ double)
      ※ 정밀도 : 오차 없는 자리수
      ex) 3.4 x 10 38승
      s | E() | M
      s : 부호
      E :  지수 → 38
      M : 가수 → 3.4


    ● 참조형 (reference type)
    - 기본형을 제외한 나머지 (String, System 등)
    - 무한개
    - 메모리 주소를 저장 (4byte 또는 8 byte)
    - 32bit JVM : 4byte 40억 (4GB)
    - 64bit JVM : 8byte 40억 x 40억 160경 바이트 (1600만 테라바이트)
    
    ● 기본형 표현범위
    8bit = 1byte
    1bit ⇒ 0,1 둘 중 하나의 값. 2진수 한자리
    n비트로 표현할 수 있는 값의 개수 : 2n승 개

#### 컴퓨터 기억용량 단위
    1byte = 8bit (바이트)
    1KB = 1,024 byte (킬로바이트)
    1MB = 1,024 KB (메가바이트)
    1GB = 1,024 MB (기가바이트)
    1TB = 1,024 GB (테라바이트)
    1PB = 1,024 TB (페타바이트)
    1EB = 1,024 PB (엑시바이트)
    1ZB = 1,024 1EB (제타바이트)
    1YB = 1,024 1ZB (요타바이트)


#### 기억(저장)용량의 단위 상세
> - RAM, HDD, VGA card, Cache, Buffer의 단위로 사용
> 
> | **이름** | 기호  | 2진 기준| 값|                                     
> |:----|:-----|:--------------------------------------|---------------------------------------:|
> | kilo byte | KB  | 2<sup>10</sup> Byte| 1,024 Byte| 
> | mega byte | MB  | 2<sup>20</sup> Byte| 1,048,576 Byte|                        
> | giga byte | GB  | 2<sup>30</sup> Byte| 1,073,741,824 Byte|                    
> | tera byte | TB  | 2<sup>40</sup> Byte| 1,099,511,627,776 Byte|                
> | peta byte | PB  | 2<sup>50</sup> Byte| 1,125,899,906,842,624 Byte|            
> | exa byte | EB  | 2<sup>60</sup> Byte| 1,152,921,504,606,846,976 Byte|         
> | zetta byte | ZB  | 2<sup>70</sup> Byte| 1,180,591,620,717,411,303,424 Byte| 
> | yotta byte | YB  | 2<sup>80</sup> Byte| 1,208,925,819,614,629,174,706,176 Byte|
>
> - RAM 용량 (사람은 MB, GB 단위 사용, 컴퓨터는 KB 단위를 사용) <p>
>   512MB = 512 x 1,024KB = 524,288 KB<p>
>   1GB = 1,024 x 1,024KB = 1,048,576 KB<p>
>   4GB = 4 x 1,024 x 1,024KB = 4,194,304 KB<p>
>
> 
> - HDD 용량 (사람은 GB, TB 단위 사용, 컴퓨터는 MB 단위를 사용)
>   10GB = 10 x 1,024MB = 10,240 MB<p>
>   500GB = 500 x 1,024MB = 512,000 MB<p>
>   1TB =  1,024 x 1,024MB = 1,048,576 MB<p>

#### [ch2-07~08]  
    - char '' 홑 따옴표 안에 하나의 문자값 존재해야한다.
    - 문자열 결합은 왼쪽에서 오른쪽으로 진행되기 때문에 순서에 따라 전혀 다른 결과가 나올 수도 있다.

#### [ch6-14~16]  
    - 객체는 변수 묶어 놓은 것.
    - 지역변수 : 메서드 내에 선언된 변수 (메서드의 매개변수 또한 지역변수이다!)
    - 인스턴스 변수(전역변수/객체변수), 클래스 변수(전역변수/Static 변수), 지역변수

#### 선언 위치에 따른 변수
    - 객체는 속성과 기능이 있다.
    - 클래스는 멤버변수와 메서드가 있음.
    - 멤버 변수는 데이터를 담는 그릇이라 표현하고, 속성이라 부르기도 한다.
    - 공통속성, 개별속성 2가지로 존재한다.
    - 공통속성은 클래스변수(static 변수 혹은 전역변수) 1가지 종류가 있다.
    - 개별속성 인스턴스 변수(객체변수 혹은 전역변수), 메소드 변수(지역변수) 2가지 종류로 분류된다.

#### [ch6-29] 메서드 간의 호출과 참조    
    - static 메소드란 : 객체생성없이 호출 가능한 메서드. 언제나 사용가능.  
    - static 메소드를 붙일지 말지 결정? 여러 클래스에서 공통으로 사용할 때 (공통속성)으로 사용하기 위해서   
    - static 메소드는 인스턴스 변수 사용 불가.   
      왜? 객체생성을 하지않고 인스턴스 변수 사용할 수 없다. (객체 생성 후 호출 가능하기때문에.)  
    ※ static 메소드가 인스턴스 메소드 호출 안됨.  
    iv : 인스턴스 변수 (개별속성)  
    cv : 클래스 변수 (공통속성)  
    객체는 iv 변수의 묶음이다.  

#### [ch6] 생성자    
    모든 클래스는 1개 이상의 생성자를 가져야 한다.  
    -> 생성자가 하나도 없을 때 컴파일러가 기본생성자 자동추가함.  

#### [ch6] 생성자this()  
    생성자에서 다른 생성자 호출할 때 사용  
    다른 생성자 호출 시 첫 줄에서만 사용가능.  

#### [ch6]참조변수 this  
    지역변수와 인스턴스변수를 구별할때 사용.  
    멤버변수(인스턴스변수, static 변수)는 자동 초기화되고, 지역변수는 수동 초기화 해야함.  

#### [ch7] 
    명시적 초기화해서 대입이 된다.   
    Class a = new Class() // 참조변수의 초기화  
    1. Class a 초기화 되고  
    2. 객체가 만들어지면서 멤버변수 값들이 대입이 된다.  
    Class a -> 초기화 아님. 저장 공간 안만들어졌음.  

#### [ch7] 객체지향개념  
    단일상속 : 하나의 부모만 상속을 허용한다.  

#### [ch7] Object클래스  
    부모가 없는 클래스는 자동적으로  Object클래스를 상속받게 된다.  

#### [ch7] toString()  
    클래스명@객체의 주소값(정확하게는 주소값은 아니다)  

#### [ch7] 오버로딩 라이딩.    
    오버로딩 : 메소드명은 동일하고 매개변수가 다른 것.  
    오버라이딩 : 메소드명, 매개변수 동일하고 내용을 재정의 하는 것.  
    
    오버로딩 : 동일한 메서드를 여러개 가질 수 있는 걸 말합니다. 단, 메서드 매개변수 숫자/타입이 다릅니다.  
    오버라이딩 : 부모클래서에서 상속받은 메서드를 재정의하는 것 

#### [ch7] 오버라이딩 조건  
    1. 선언부가 조상 클래스의 메서드와 일치해야 한다.  
    2. 접근 제어자가를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.  
    public,protected, private  
    3. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.  

    this : lv와 iv 구별에 사용.  
    super : 조상멤버과 자신멤버 구별할 때 사용.   

#### [ch7] 상속 : 생성자, 초기화블럭 상속 x  
    super() 호출해서 조상 생성자는 조상클래스가 초기화하게 하는 것.  
    자식클래스에서 조상 생성자를 호출할때 super를 쓴다.  
    
    조상이 선언한 멤버들을 초기화 할때 자식이 할게 아니라  
    자식클래스에서 조상생성자를 호출해서 조상의 클래스가 초기화 하도록 한다.  

#### [ch7] super() - 조상의 생성자  
    생성자 첫 줄에 반드시 생성자를 호출해야 한다.  
    그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입.  
    
    모든 생성자는 첫 줄에 다른 생성자를 호출해야한다.   
    그렇지 않으면 컴파일러가 자동 super();를 삽입한다.  
    
    기본 생성자 작성은 필수다!  

#### [ch7] import문 선언  
    이름이 같은 클래스가 속한 두 패키지를 import할 때는  
    클래스 앞에 패키지명을 붙여줘야 한다.  

#### [ch7] static import문  
    static멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.  
    -> 웬만하면 쓰지 않는게 좋다. 클래스 이름이 있으면 명확하게 알아보기 좋다.  

#### [ch7] 제어자  
    ● 접근 제한자 : public > protected> default > private (총4개)  
    ● 그 외 : static, final, abstract
    * public 안쓰면 default로 써야함.
    * 접근 제어자는 제일 왼쪽, 1개만 쓸 수 있다.
    * 클래스는 public, (default) 접근 제어자만 가능하다

#### [ch7] static 변수와 메서드
    ● static 변수(멤버변수)
        - 클래스가 메모리에 로드될 때 생성된다.
        - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
        - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능하다.
    ● static 메서드
        - 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
        - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.
        - static 변수의 복잡한 초기화 수행

#### [ch7] final 접근제어자 (노변경)
    ● final 클래스
        - 변경될 수 없는 클래스
        - 확장될 수 없는 클래스 (final로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.)
    ● final 메서드
        - 변경될 수 없는 메서드
        - 재정의 될 수 없는 메서드 (final로 지정된 메서드는 오버라이딩을 통해 재정의 할 수 없다.)
    ● final 변수
        - 멤버변수(클래스, 인스턴스), 지역변수 앞에 final 붙으면, 값을 변경할 수 없는 상수가 된다.

#### [ch7] abstract 접근제어자 (미완성)
    ● abstract 클래스
        - 클래스 내에 추상 메서드가 선언되어 있음을 의미
        - 추상 메서드가 포함한 클래스
        - 추상 클래스는 인스턴스(객체) 생성 불가
        - 추상 클래스를 상속받아 완전한 클래스로 만든 후에 객체 생성 가능
    ● abstract 메서드
        - 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드이다.
    
#### [ch7] 클래스내 static 초기화 블럭 
    static {} // 클래스 초기화 블럭  
    -> static 변수의 복잡한 초기화 수행.  

#### [ch7] 접근 제어자 (접근 범위)   
    public > protected> default > private (총4개)  
    접근제한 없음 > 같은 패키지 + 자손(다른 패키지) > 같은 패키지 > 같은 클래스  

#### 캡슐화와 접근 제어자
    - 접근 제어자를 사용하는 이유?
    - 외부로부터 데이터를 보호하기 위해서
        - ex) 접근 제어자를 private 하여 외부에서 직접 접근하지 못하도록 하고, 함수를 구현하여 간접접근 허용하게 만든다.
    - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서

#### 추상클래스 (abstract class)
    - 추상 메서드를 갖고 있는 클래스 (미완성의 설계도)
        추상 메서드만 갖고 있는 게 아님. 일반 클래스의 구성 + 추상메서드를 추가로 갖고 있는 것
    - 상속을 통해 추상 메서드를 완성해야 인스턴스 생성 가능
    - 추상메서드 : 메서드에 선언부만 있고 구현부는 없는 abstract 제어자가 붙은 메서드

#### 추상클래스 장점
    - 여러 클래스에 공통부분을 뽑아서 만듬
    - 다른 클래스 작성에 도움을 주기 위한 것
    - 자손마다 다르게 구현될 것으로 예상되는 경우
    - 변경에 유리

#### 추상클래스  상속
    - 상속받은 추상메서드 모두 Override 해야함. 안하면 오류남
    - Class cannot extend multiple classes

#### 인터페이스(interface)
    - 추상메서드의 집합 (부수적 : static메서드 몸통포함, default 메서드 몸통포함, 상수 포함)
    - 멤버 변수를 가질 수 없음
    - 모든 멤버가 public
    - public static final 타입 상수명 = 값;
    - public abstract 메서드 이름 ();

#### 인터페이스 상속   
    - 인터페이스의 상속은 인터페이스 타입인 조상만 상속 받을 수 있음
    - 다중 상속이 가능 (추상메서드 충돌해도 문제없음)
        - 왜? 선언부라서 상관없음
    - public interface Child extends Parents, Grandparents

#### 인터페이스 구현
    - class 클래스 이름 implements 인터페이스명
    - 인터페이스에 정의된 추상메서드를 모두 구현해야 함
    - 단, 일부만 구현하는 경우 클래스 앞에 abstract 붙여야 함 (추상 메서드를 갖고 잇음)

#### extends vs implements
    - 일반 클래스, 추상 클래스, 인터페이스의 상속 모두 extends
    - 인터페이스의 상속 후 구현은 implements

#### [ch7] 인터페이스 장점  
    - 표준화 가능  
    - 변경에 유리한 유연한 설계 가능  
    - 선언(설계)와 구현을 분리시킬 수 있게 한다.  
    - 구현한 클래스가 변경되어도 선언(조상)은 안바꿀 수 있게 된다. (느슨한 결합)   
    - 서로 관계없는 클래스들을 관계를 맺어줄 수 있다.  

#### [ch7] 인터페이스 구현
    인터페이스를 구현한 것만 매개변수로 가능

#### 추상 클래스와 인터페이스의 차이?
    - 인터페이스는 모든 멤버가 public이며 멤버변수가 상수만 허용가능, 추상 클래스는 모든 접근 제어자 허용
    - 인터페이스는 다중상속 가능하나 추상 클래스는 다중상속 불가능
    - 인터페이스는 디폴트 생성자, static 메서드를 제외하곤 추상메서드만 가능하지만, 추상 클래스는 일반 메서드 구현도 가능
    - 인터페이스는 설계와 구현을 불리해 변경에 유리한 유연함 가짐, 추상 클래스는 확장성에 용이
    
#### [ch8] 예외처리
    프로그램 오류 
    - 컴파일에러(compile-time error) : 컴파일 할 때 발생하는 에러 (구문 및 문법 오류, 대표적으로 Syntax error, {} () '' "" 짝이 안맞을 때 등등)  
    - 런타임에러(runtime error) : 실행 할 때 발생하는 에러 (잘못된 개발설계로 대표적인 NullpointException, CastException, 무한루프, 0/0 등등)  
    - 논리적에러(logical error) : 작성 의도와 다르게 동작 (로직 오류로 인한 잘못된 계산)  
    
    런타임에러
    - Error : 심각한 에러
    - Exception : 미약한 에러
        - Exception 처리
        - RunTimeException 처리

#### [ch9-25] 래퍼클래스
    기본형의 값을 감싸는 클래스
    * 8개의 기본형을 객체로 다뤄야 할 때
    * 래퍼클래스 성능문제로 기본형 8가지가 나옴

#### [ch9-27] Number 클래스
    모든 숫자 래퍼클래스의 조상  (8개 기본형을 감싸는 클래스)
    Number 클래스는 기본형Value() 추상메소드를 가지고 있음.
    -> 래퍼 객체의 값을 기본형으로 바꿔주는 메소드들을 갖고 있음 

#### [ch9-28] 오토박싱 vs 언박싱  
    기본형 <-> 래퍼클래스         
    - 오토박싱 : 기본형 -> 래퍼클래스  
    - 언박싱 : 래퍼클래스 -> 기본형  
    
    * 문자열 -> 기본형  
    래퍼클래스.parse래퍼클래스()  
    
    * 문자열 -> 래퍼클래스  
    래퍼클래스.valueOf(문자열)  
 
#### [ch11] 컬렉션프레임워크(collections framework) 
     * 컬렉션(collection)  
     여러 객체(데이터)를 모아 놓은 것을 의미  
     
     * 프레임워크(framework) 
     프로그램을 만들 때 정해진 틀
     표준화, 정형화된 체계적인 프로그래밍 방식
     프레임워크를 사용하면 생산성이 올라가고 유지보수에 용이합니다
     ※ lib : 기능
     
     * 컬렉션프레임워크(collections framework)
     다수의 데이터를 다루기 위해 존재
     컬렉션을 다루기 위한 표준화된 프로그래밍 방식 
     컬렉션을 쉽게 편리하게 다룰 수 있는 다양한 클래스 제공  
     java.util 패키지에 포함. jdk1.2부터 제공  
     ※ 객체를 다룬다는 것은 객체를 저장,삭제,검색, 정렬을 하는 것을 의미한다. 
     ※ 다루는 데이터의 특징에 맞는 클래스를 선택해서 사용하면 된다! 
     
     * 컬렉션 클래스 
     다수의 데이터를 저장할 수 있는 클래스 (ArrayList/vector, HashSet) 
     
     * vector -> ArrayList의 old버전 대신 동기화 됨. ArrayList에도 동기화가 처리가능하도록 추가되었다? 
     
#### [ch11] List, Set, Map 간단 정리 
     * 데이터를 다루기 위한 인터페이스는 크게 3가지 존재합니다. 
     List, Set, Map 이고, 
     
     List : 순서 O, 중복 O 
     Set : 순서 X, 중복 X 
     Map : 순서 X, Key-중복 X, Value-중복 O 
     
     구현 클래스의 명칭에 3가지가 포함되어 있다면 
     상위 3가지를 구현한 클래스 입니다. 
     
     또한, List와 Set은 반대의 성격이나 공통된 부분을 모아 Collection이라고 부릅니다. 
     Map의 경우는 Key와 Value 쌍으로 이루어진 데이터 집합니다. 
     
     
#### [ch11] List
    1.LinkedList (연결리스트)
    @ 데이터 접근성이 나쁘다
    - next 다음요소만 안다
    - 뒤에 요소 모른다
    - 한번에 두세개 요소 건너뛰지 못함

    2.Doubly LinkedList (이중 연결리스트)
    @앞뒤 이동 접근성 향상
    - next, previous 다음 이전 요소 안다
    - 여전히 한번에 두세개 요소 건너뛰는 게 안됨

    3.Doubly Circle LinkedList (이중 원형 연결리스트)
    @ 맨앞, 맨뒤 요소 접근성 향상
    - 맨앞,맨뒤 요소 연결
    - 실제로 자바에서는 이중 연결리스트로 구현되어 있다.
    - 여전히 배열보다 접근성이 나쁘다는 단점을 가지고 있다.

#### [ch11] STACK VS QUEUE
    STACK
    클래스 
    QUEUE
    큐는 인터페이스로 큐 객체 선언할때 큐로 구현한 구현체로 선언해야함.

#### [ch12-1] 제네릭스 generics
    제네릭스란?
    - 개념 : 컴파일시 타입을 체크해주는 기능. 타입 체크 강화
    - 요약 : 컴파일러에게 타입정보를 전달하여 타입을 체크하여 형변환 에러를 줄이기 위함.
    - 정리 : RuntimeError 에서 CompileError 체크할 수 있게 CompileError level로 끌어온 것이 제네릭스
    - 장점 :  컴파일 타임에서 타입 체크 강화하여 타입의 안정성을 높히고 형변환 번거로움이 줄어 코드가 간결해진다.
    
    초기화
    - String str = null; < String str = "";
    - Object[] objArr = null; < Object[] objArr = Object[0]; or {};
    - NullPointerException 발생 줄이기 위해서
    
    타입변수
    - Object타입 대신 타입변수 (E)를 선언해서 사용.
    - <E> element의 의미일 때 쓰고 보통 <T>를 주로 쓴다.
    
    제네릭스 타입변수 객체의 다형성
    - 타입변수<E> 대신, 실제 타입<객체>을 지정(대입)
    - ↑ 타입변수 대신, 실제 타입을 지정하면 형변환 생략가능

    클래스든, 메서드든 제네릭 참조변수가 선언되어 있으면 재네릭 클래스/메서드가 된다.
    
    와일드카드?
    와일드카드가 안될 때 제네릭 메서드 쓰는 경우가 많다.

#### [ch12 4~6] 제네릭스 용어, 제네릭 타입과 다형성
    - Class Box<T> 
        → Box<T> : 제네릭스 클래스
        → Box : 원시타입
        → T : 타입변수 T선언
    
    - Box<String> b = new Box<String>();
        → 타입변수에 실제 타입 대입
        → 매개변수화된 타입 (대입된 타입이라고 함. parameterized type)

    - 제네릭 타입과 다형성
        → 제네릭 클래스간의 다형성은 성립
        → 매개변수의 다형성도 성립
        → 참조변수와 생성자의 대입된 타입은 일치해야함
            ex)ArrayList<String> list = new ArrayList<String>();

    - 여러 개의 타입 변수가 필요한 경우 콤마(,)를 구분자로 선언
    - 생성자에 타입지정 생략가능.

#### [ch12 9~11] 제한된 제네릭 클래스, 제약
    ● class
    - extends로 대입할 수 있는 타입을 제한
    - ex) class FruitBox<T extends Fruit> Fruit의 자손만 타입으로 지정가능
    
    ● interface
    - 인터페이스인 경우에도 extends를 사용

    ● class, interface 동시에
    - 동시에 사용하는 경우 &를 씀
    - ex) class FruitBox<T extends Fruit & Eatable>

    ● 제약 2가지
    - 1. static 멤버에 타입 변수 사용 불가
        - 이유? static 멤버는 모든 인스턴스 공통이기 때문
        - 타입 변수에 대입은 인스턴스 별로 다르게 가능
    - 2. 객체 및 배열 생성 할 때 타입 변수 사용 불가
        - 즉, new T 안됨!
        - 타입 변수로 배열 선언은 가능

#### [ch12 12~14] 와일드 카드<?>, 지네릭 메서드
    ● 와일드 카드 <?>
        - 하나의 참조 변수로 대입된 타입이 다른 객체를 참조 가능
            - <? extends T> T와 그 자손들만 가능. 와일드 카드의 상한 제한.
            - <? super T> T와 그 조상들만 가능. 와일드 카드의 하한 제한.
            - <?> 제한 없음. 모든 타입 가능 <? extends object>와 동일
        - 메서드의 매개변수에 와일드 카드를 사용
    ● 지네릭 메서드
        -  지네릭 타입이 선언된 메서드
            - 타입변수는 메서드 내에서만 유효
        - 클래스 타입 매개변수 <T>와 메서드의 타입변수 <T>는 별개!
        - 메서드를 호출할 때마다 타입을 대비해야함
            - 타입 생략 가능하나 클래스명은 생략 불가
        - 제네릭 메서드 vs 와일드 카드 메서드
            - 제네릭 메서드는 호출할 때마다 타입이 다름
            - 와일드 카드 메서드는 호출할 때의 여러 제네릭 객체의 매개변수를 다루기 위함

#### [ch12 15~16] 지네릭형변환
    - 컴파일러는 지네릭 타입을 제거하고, 필요한 곳에 형변환을 넣음.
        1. 지네릭 타입의 경계를 제거
        2. 지네릭 타입 제거 후에 타입이 불일치하면, 형변환을 추가
        3. 와일드 카드가 포함된 경우, 적절한 타입으로 형변환 추가

#### [ch12 17~20] 열거형
    - 열거형 정의
        - enum 열거형명 {상수명1, 상수명2, ...}
    - 열거형 상수 비교
        - == (등가비교 연산자)
        - compareTo() 
            - ex) 상수명1.compareTo(상수명2) 상수명1 인덱스(순서) - 상수명2 인덱스(순서)
        - equals() 가능
    - Enum 클래스 메서드
        - String name() : 열거형 상수의 이름을 문자열로 반환
        - int ordinal() : 열거형 상수가 정의된 순서를 반환 (0부터)
        - values() : 열거형 모든 상수를 배열로 반환

#### [ch12 21~22] 열거형멤버추가하기
    - 불연속적인 열거형 상수의 경우, 원하는 값을 괄호()안에 적는다.
    - 괄호()를 사용하려면, 인스턴스 변수와 생성자를 새로 추가해줘야 한다.
    - 열거형의 생성자는 묵시적으로 private이므로, 외부에서 객체생성 불가

#### [ch12 23~24] 애너테이션
    - 프로그래밍 언어에 영향을 미치지 않으며, 유용한 정보(설정 정보)를 제공

#### [ch12 25~26] 표준애너테이션
    - @Override : 오버라이딩을 올바르게 했는 지 컴파일러가 체크하게 한다.
    - @Deprecated : 앞으로 사용하지 않을 것을 권장하는 필드나 메서드에 붙인다.
    - @FunctionalInterface : 함수형 인터페이스는 하나의 추상 메서드만 가능하다.
    - @SuppressWarnings : 컴파일러의 경고메시지가 나타나지 않게 억제한다.

#### [ch12 13~1] 쓰레드
    ● process, thread
        - 프로세스 : 실행 중인 프로그램. 자원(resources, 메모리, cpu)과 쓰레드로 구성
        - 쓰레드 :  프로세스 내에 실제 작업을 수행
        - 프로세스(공장), 쓰레드(일꾼)
    ● 멀티쓰레드의 장점?
        - 자원을 효율적으로 사용
        - 사용자 응답성 향샹
        - 작업 분리로 코드 간결
    ● 멀티쓰레드의 단점?
        - 자원의 공유성
        - 동기화(syncronization) 주의
        - 교착상태(dead-lock) 발생하지 않게 주의. 기아(굶어죽는)
        - 각 쓰레드를 효율적으로 실행되게 해야함.

#### [ch12 3~6] 쓰레드 구현과 실행
    - 쓰레드 생성 new Thread()
    - 쓰레드 실행 thread.start()
        - start() 메소드 호출한다고 바로 실행하는 것이 아니다.
        - os 스케줄러가 실행순서 결정함.
        - JVM이 OS에 독립적이라고 하지만, 쓰레드는 예외로 종속정이다.
    - Thread 상속 및 구현할 때 run() 오버라이딩 하는데 왜 start() 메소드를 씀?
        - start() 메소드 안에 run() 있음
        - run() 새로운 호출스택을 생성해서 독립적으로 작업 수행한다.
        - start()는 메인 메서드 안에서 돌아갑니다.

#### [ch13 7~13] 싱글 쓰레드와 멀티 쓰레드
    ● 메인 쓰레드의 종료
    - 메인 쓰레드(public static main)가 종료되어도, 다른 쓰레드가 실행 중이면 프로그램 종료되지 않는다.

    ● 멀티 쓰레드 장점?
    - 어떤 한 작업이 수행되는 동안 다른 외부적인 요인에 의해서 멈춰있을 때
      다른 쓰레드를 작업할 수 있어서 작업을 좀 더 효율적으로 빨리 끝낼 수 있다는 게 멀티 쓰레드 장점입니다.
    -> context switching 문맥교환이라고 한다.


#### [ch13 14~17] 쓰레드의 우선순위, 쓰레드 그룹
    ● 쓰레드의 우선순위
    - 확률적으로 높은거지 불확실하다. 
    
    ● 쓰레드 그룹
    - 스레드 들은 기본적으로 그룹으로 묶여서 다뤄지고 스레드을 관리할 때 그룹으로 묶어서 다룰 수 있다.
    - 하나의 쓰레드 그룹에 모든 쓰레드가 포함되어 있다.
        - 그룹을 정하지 않으면 메인 쓰레드 그룹에 속한다.

#### [람다1] T
    클래스 밖에 있는 걸 함수라 부른다.
    자바에서는 클래스 밖에 있을 수 없기 때문에 전부다 메서드이다.
    람다 사용할 때 무조건 인터페이스 작성해야하는 지?
    함수형 인터페이스 -> @ 애너테이션 쓰기.


#### [ch14] 람다와 스트림
    - 함수와 메서드 차이?    
     근본적으로 동일. 함수는 일반적 용어. 메서드는 객체지향개념 용어 . 
     함수는 클래스의 독립적, 메서드는 클래스에 종속적  ....
     -> 함수는 클래스 외부, 메서드는 클래스 내부. 클래스 밖에 있는 걸 함수라고 부른다. 자바에서 클래스는 밖에 있을 수 없기 때문에 전부 메서드이다.  

