# Java의 정석 - 학습 내용 정리
_Assembled by yunjin (2022-05-27)_

</br>

## 📍 책 소개

<img src="https://storage.googleapis.com/static.fastcampus.co.kr/prod/uploads/202109/104011-472/group-1799.png" width="300">

처음부터 끝까지 상세하게 알려주신다. 자바 기본 문법을 충실하게 공부해서 기초 주축을 준비하는데 좋은 책 입니다.

:information_desk_person: 책을 읽으면서 중요하다고 생각되는 내용 위주로 작성한 정리본입니다.  

<br/>

## 📍 간단한 리뷰 코너

- 별점 : ★★★★☆
- 리뷰 : 단월별 구성이 잘되어 있고, 자바 기본 문법부터 객체지향 프로그램, 컬렉션 프레임 워크, 람다까지 기본적인 지식을 공부할 수 있어서 좋았습니다.

<br/> 
 
## 📍 정리

#### [ch1]  
    - 파이썬 91년, 자바 96년
    - 자바8부터 함수형 기능 추가.  
    - JDK : 자바 개발도구  
    - 원래는 3년마다 버전 Update.   
    - 자바8부터 6개월마다 버전 Update  
 
#### [ch1]  자바특징  
    - 프로그래밍 언어 + 객체지향 개념.  
      객치지향 언어 : C++, java,Python, js  
      ※ Python : 접근성은 좋지만, 객체지향 개념을 깊이 다루기에 어렵다.  
    
    - 자동 메모리 관리.  
      가비지 컬렉터 GC 메모리 자동 정리해줌. (프로그래머가 일일이 정리하지 않아도 된다.)  
    
    - 멀티 쓰레드 지원  
       하나의 프로그램에서 동시에 여러 작업을 하게 해줌.  
    
    - 풍부한 라이브러리로 쉽게 개발가능.  
    
    - 운영체제에 독립적  
      여러 운영체제에서 사용 가능.  

#### [ch1]  자바 가상 머신 (JVM)   
    - Macintosh : mac(맥)  
    - jvm만 설치되어 있으면 한번 작성. 운영체제 관계없이 어디서든 실행 가능.  
    - write once, run anywhere  

#### [ch14] 람다와 스트림  
    - 함수와 메서드 차이?    
     근본적으로 동일. 함수는 일반적 용어. 메서드는 객체지향개념 용어  
     함수는 클래스의 독립적, 메서드는 클래스에 종속적  
     -> 함수는 클래스 외부, 메서드는 클래스 내부. 클래스 밖에 있는 걸 함수라고 부른다. 자바에서 클래스는 밖에 있을 수 없기 때문에 전부 메서드이다.  

#### [ch2 7,8]  
    - char '' 홑 따옴표 안에 하나의 문자값 존재해야한다.
    - 문자열 결합은 왼쪽에서 오른쪽으로 진행되기 때문에 순서에 따라 전혀 다른 결과가 나올 수도 있다.

#### [ch6-14~16]  
    - 객체는 변수 묶어 놓은 것.
    - 지역변수 : 메서드 내에 선언된 변수 (메서드의 매개변수 또한 지역변수이다!)
    - 인스턴스 변수(전역변수/객체변수), 클래스 변수(전역변수/Static 변수), 지역변수

#### [ch6-29] 메서드 간의 호출과 참조    
    - static 메소드란 : 객체생성없이 호출 가능한 메서드. 언제나 사용가능.  
    - static 메소드를 붙일지 말지 결정? 여러 클래스에서 공통으로 사용할 때 (공통속성)으로 사용하기 위해서   
    - static 메소드는 인스턴스 변수 사용 불가.   
      왜? 객체생성을 하지않고 인스턴스 변수 사용할 수 없다. (객체 생성 후 호출 가능하기때문에.)  
    ※ static 메소드가 인스턴스 메소드 호출 안됨.  
    iv : 인스턴스 변수 (개별속성)  
    cv : 클래스 변수 (공통속성)  
    객체는 iv 변수의 묶음이다.  

#### [ch6] 생성자    
    모든 클래스는 1개 이상의 생성자를 가져야 한다.  
    -> 생성자가 하나도 없을 때 컴파일러가 기본생성자 자동추가함.  

#### [ch6] 생성자this()  
    생성자에서 다른 생성자 호출할 때 사용  
    다른 생성자 호출 시 첫 줄에서만 사용가능.  

#### [ch6]참조변수 this  
    지역변수와 인스턴스변수를 구별할때 사용.  
    멤버변수(인스턴스변수, static 변수)는 자동 초기화되고, 지역변수는 수동 초기화 해야함.  

#### [ch7] 
    명시적 초기화해서 대입이 된다.   
    Class a = new Class() // 참조변수의 초기화  
    1. Class a 초기화 되고  
    2. 객체가 만들어지면서 멤버변수 값들이 대입이 된다.  
    Class a -> 초기화 아님. 저장 공간 안만들어졌음.  

#### [ch7] 객체지향개념  
    단일상속 : 하나의 부모만 상속을 허용한다.  

#### [ch7] Object클래스  
    부모가 없는 클래스는 자동적으로  Object클래스를 상속받게 된다.  

#### [ch7] toString()  
    클래스명@객체의 주소값(정확하게는 주소값은 아니다)  

#### [ch7] 오버로딩 라이딩.    
    오버로딩 : 메소드명은 동일하고 매개변수가 다른 것.  
    오버라이딩 : 메소드명, 매개변수 동일하고 내용을 재정의 하는 것.  
    
    오버로딩 : 동일한 메서드를 여러개 가질 수 있는 걸 말합니다. 단, 메서드 매개변수 숫자/타입이 다릅니다.  
    오버라이딩 : 부모클래서에서 상속받은 메서드를 재정의하는 것 

#### [ch7] 오버라이딩 조건  
    1. 선언부가 조상 클래스의 메서드와 일치해야 한다.  
    2. 접근 제어자가를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.  
    public,protected, private  
    3. 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.  

    this : lv와 iv 구별에 사용.  
    super : 조상멤버과 자신멤버 구별할 때 사용.   

#### [ch7] 상속 : 생성자, 초기화블럭 상속 x  
    super() 호출해서 조상 생성자는 조상클래스가 초기화하게 하는 것.  
    자식클래스에서 조상 생성자를 호출할때 super를 쓴다.  
    
    조상이 선언한 멤버들을 초기화 할때 자식이 할게 아니라  
    자식클래스에서 조상생성자를 호출해서 조상의 클래스가 초기화 하도록 한다.  

#### [ch7] super() - 조상의 생성자  
    생성자 첫 줄에 반드시 생성자를 호출해야 한다.  
    그렇지 않으면 컴파일러가 생성자의 첫 줄에 super();를 삽입.  
    
    모든 생성자는 첫 줄에 다른 생성자를 호출해야한다.   
    그렇지 않으면 컴파일러가 자동 super();를 삽입한다.  
    
    기본 생성자 작성은 필수다!  

#### [ch7] import문 선언  
    이름이 같은 클래스가 속한 두 패키지를 import할 때는  
    클래스 앞에 패키지명을 붙여줘야 한다.  

#### [ch7] static import문  
    static멤버를 사용할 때 클래스 이름을 생략할 수 있게 해준다.  
    -> 웬만하면 쓰지 않는게 좋다. 클래스 이름이 있으면 명확하게 알아보기 좋다.  

#### [ch7] 제어자  
    - 접근 제어자 : public > protected> default > private (총4개)  
    - 그 외 : static, final
    * public 안쓰면 default로 써야함.

#### [ch7] 클래스내 static 초기화 블럭 
    static {} // 클래스 초기화 블럭  
    -> static 변수의 복잡한 초기화 수행.  

#### [ch7] 접근 범위   
    public > protected> default > private (총4개)  
    접근제한 없음 > 같은 패키지 + 자손(다른 패키지) > 같은 패키지 > 같은 클래스  

#### [ch7] 인터페이스 장점  
    - 표준화 가능  
    - 변경에 유리한 유연한 설계 가능  
    - 선언(설계)와 구현을 분리시킬 수 있게 한다.  
    - 구현한 클래스가 변경되어도 선언(조상)은 안바꿀 수 있게 된다. (느슨한 결합)   
    - 서로 관계없는 클래스들을 관계를 맺어줄 수 있다.  

#### [ch7] 인터페이스 구현
    인터페이스를 구현한 것만 매개변수로 가능
    
#### [ch8] 예외처리
    프로그램 오류 
    - 컴파일에러(compile-time error) : 컴파일 할 때 발생하는 에러 (구문 및 문법 오류, 대표적으로 Syntax error, {} () '' "" 짝이 안맞을 때 등등)  
    - 런타임에러(runtime error) : 실행 할 때 발생하는 에러 (잘못된 개발설계로 대표적인 NullpointException, CastException, 무한루프, 0/0 등등)  
    - 논리적에러(logical error) : 작성 의도와 다르게 동작 (로직 오류로 인한 잘못된 계산)  
    
    런타임에러
    - Error : 심각한 에러
    - Exception : 미약한 에러
        - Exception 처리
        - RunTimeException 처리

#### [ch9-25] 래퍼클래스
    기본형의 값을 감싸는 클래스
    * 8개의 기본형을 객체로 다뤄야 할 때
    * 래퍼클래스 성능문제로 기본형 8가지가 나옴

#### [ch9-27] Number 클래스
    모든 숫자 래퍼클래스의 조상  (8개 기본형을 감싸는 클래스)
    Number 클래스는 기본형Value() 추상메소드를 가지고 있음.
    -> 래퍼 객체의 값을 기본형으로 바꿔주는 메소드들을 갖고 있음 

#### [ch9-28] 오토박싱 vs 언박싱  
    기본형 <-> 래퍼클래스         
    - 오토박싱 : 기본형 -> 래퍼클래스  
    - 언박싱 : 래퍼클래스 -> 기본형  
    
    * 문자열 -> 기본형  
    래퍼클래스.parse래퍼클래스()  
    
    * 문자열 -> 래퍼클래스  
    래퍼클래스.valueOf(문자열)  
 
#### [ch11] 컬렉션프레임워크(collections framework) 
     * 컬렉션(collection)  
     여러 객체(데이터)를 모아 놓은 것을 의미  
     
     * 프레임워크(framework) 
     프로그램을 만들 때 정해진 틀
     표준화, 정형화된 체계적인 프로그래밍 방식
     프레임워크를 사용하면 생산성이 올라가고 유지보수에 용이합니다
     ※ lib : 기능
     
     * 컬렉션프레임워크(collections framework)
     다수의 데이터를 다루기 위해 존재
     컬렉션을 다루기 위한 표준화된 프로그래밍 방식 
     컬렉션을 쉽게 편리하게 다룰 수 있는 다양한 클래스 제공  
     java.util 패키지에 포함. jdk1.2부터 제공  
     ※ 객체를 다룬다는 것은 객체를 저장,삭제,검색, 정렬을 하는 것을 의미한다. 
     ※ 다루는 데이터의 특징에 맞는 클래스를 선택해서 사용하면 된다! 
     
     * 컬렉션 클래스 
     다수의 데이터를 저장할 수 있는 클래스 (ArrayList/vector, HashSet) 
     
     * vector -> ArrayList의 old버전 대신 동기화 됨. ArrayList에도 동기화가 처리가능하도록 추가되었다? 
     
#### [ch11] List, Set, Map 간단 정리 
     * 데이터를 다루기 위한 인터페이스는 크게 3가지 존재합니다. 
     List, Set, Map 이고, 
     
     List : 순서 O, 중복 O 
     Set : 순서 X, 중복 X 
     Map : 순서 X, Key-중복 X, Value-중복 O 
     
     구현 클래스의 명칭에 3가지가 포함되어 있다면 
     상위 3가지를 구현한 클래스 입니다. 
     
     또한, List와 Set은 반대의 성격이나 공통된 부분을 모아 Collection이라고 부릅니다. 
     Map의 경우는 Key와 Value 쌍으로 이루어진 데이터 집합니다. 
     
     
#### [ch11] List
    1.LinkedList (연결리스트)
    @ 데이터 접근성이 나쁘다
    - next 다음요소만 안다
    - 뒤에 요소 모른다
    - 한번에 두세개 요소 건너뛰지 못함

    2.Doubly LinkedList (이중 연결리스트)
    @앞뒤 이동 접근성 향상
    - next, previous 다음 이전 요소 안다
    - 여전히 한번에 두세개 요소 건너뛰는 게 안됨

    3.Doubly Circle LinkedList (이중 원형 연결리스트)
    @ 맨앞, 맨뒤 요소 접근성 향상
    - 맨앞,맨뒤 요소 연결
    - 실제로 자바에서는 이중 연결리스트로 구현되어 있다.
    - 여전히 배열보다 접근성이 나쁘다는 단점을 가지고 있다.

#### [ch11] STACK VS QUEUE
    STACK
    클래스 
    QUEUE
    큐는 인터페이스로 큐 객체 선언할때 큐로 구현한 구현체로 선언해야함.

#### [ch12-1] 제네릭스 generics
    제네릭스란?
    - 컴파일시 타입을 체크해주는 기능
    - 정리 : 컴파일 타임에서 타입을 더 정확히 체크하여 타입의 안정성을 높히고, 형변환 번거로움이 줄어 코드가 간결해진다.
    - 객체 타입 안정성을 높히고, 형변환의 번거로움을 줄여줌.
    - 컴파일러에게 타입정보를 전달하여 타입을 체크하여 형변환 에러를 줄이기 위함. 
      (RuntimeError -> CompileError 체크할 수 있게 CompileError level로 끌어옴)
    - 코드가 간결해지고, 컴파일 타임에서 타입을 더 정확히 체크할 수 있다.
        
    타입변수<E>, <T>
    제네릭스 타입변수 객체의 다형성
    - 타입변수<E> 대신, 실제 타입<객체>을 지정(대입)
    - ↑ 타입변수 대신, 실제 타입을 지정하면 형변환 생략가능
    
    참고변수의 제네릭 타입과 생성자의 제네릭 타입은 같아야 한다. 
    - 생성자 재네릭 타입 생략 가능
    
    클래스든, 메서드든 제네릭 참조변수가 선언되어 있으면 재네릭 클래스/메서드가 된다.
    
    와일드카드?
    와일드카드가 안될 때 제네릭 메서드 쓰는 경우가 많다.
    
#### [람다1]T
    클래스 밖에 있는 걸 함수라 부른다.
    자바에서는 클래스 밖에 있을 수 없기 때문에 전부다 메서드이다.
    람다 사용할 때 무조건 인터페이스 작성해야하는 지?
    함수형 인터페이스 -> @ 어노테이션 쓰기



