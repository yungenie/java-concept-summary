# 모두의 자바 - 학습 내용 정리
_Assembled by yungenie (2021-06-11)_


## 📍 책 소개

<img src="https://user-images.githubusercontent.com/28051638/121692234-de9aeb80-cb02-11eb-8dce-3b5e0a6c43f7.jpg" width="300">

[`길벗-모두`]()의 시리즈로 반드시 알아야 하는 내용을 토대로 짧게 구성한 자바 프로그래밍 책입니다.

:information_desk_person: 책을 읽으면서 중요하다고 생각되는 내용 위주로 작성한 정리본입니다.  

<br/>

## 📍 간단한 리뷰 코너

- 별점 : ★★★☆☆
- 장점 : 쭉 훑어보기용으로 추천합니다. (자바를 오랜만에 공부했기에, 빨리 전체적인 내용을 이해하고 싶었음)
- 단점 : 오타로 인한 내용 혼돈.. 처음 접하는 사람들은 오해할 수도 있을 것 같다.

<br/> 

## 📍 1부) 자바 시작하기

#### 자바(java)
- 플랫폼에 독립적이다.
  - 자바로 만든 프로그램은 자바가상기계: JVM, Java Virtural Machine 만 있으면 모든 운영체제에서 실행 할 수 있음
  
- 객체지향 언어이다. 
  - 객체를 중심으로 프로그램이나 시스템을 구성하는 것
  
- 메모리 관리를 자동으로 해준다. 
  - 가비지컬렉터: GC, Garbage Collector가 메모리를 자동으로 관리한다. c, c++은 메모리 할당/회수 다 해줘야하지만, GC는 자동으로 메모리 해제시켜줌
<br/>

#### 자바 개발환경 구축
- JDK설치
- 환경 변수 설정(JAVA_HOME, Path)
- 개발 툴 설치(이클립스)
<br/>

#### 자바 개발 순서
- 자바 코드 작성
- 자바 코드 컴파일 .java -> .class (바이트 코드 파일로 변환)
- 컴파일한 코드를 JVM으로 실행합니다. (해당 운영체제에 맞는 기계어로 변환)
- 컴파일(Compile) : 사람이 알아보기 쉽게 작성한 소스코드를 컴퓨터가 알아들을 수 있는 언어로 번역하는 과정을 말합니다.
- 컴파일러(Compliler) : 컴퓨터가 이해하도록 변환하는 프로그램이 컴파일러입니다.
<br/>

#### 주석문
- 구현 주석
  - 행 단위 주석 :  //주석내용
  - 블록 단위 주석 :  /* 주석내용 */

- 문서화 주석
  - /** 주석 */
  - 클래스, 인터페이스 멤버당 하나씩 가질 수 있고, 선언 바로 전에 작성 가능하다.

<br/>

## 📍 2부) 변수와 계산

#### 변수
- 변수는 `값을 저장할 수 있는 메모리의 공간` 을 의미합니다. 프로그램이 동작하면서 값이 수시로 바뀔 수 있기 때문에 변수라고 합니다.
- 변수를 선언할 때부터 해당 변수에 어떤 데이터 타입형으로 데이터를 담을 것인지 결정해야합니다.
- 자바는 강형(strongly-typed)언어로, 용도에 맞지 않는 것을 담으면 에러가 발생합니다.
<br/>

#### 변수명
- 변수명을 정하는 규칙을 변수의 명명 규칙입니다.
<br/>

#### 명명규칙
- 한 글자 이상이어야 합니다.
- 첫 번째 글자는 문자, $, _ 이어야 합니다.
- $, _ 이외 특수문자는 사용할 수 없다.
- 길이 제한 없음.
- 키워드는 식별자로 사용할 수 없다.
<br/>

#### 명명관례
- 첫번째 문자가 소문자인 명사로 정한다.
- 여러 단어로 구성한 경우 : 두번째 단어의 첫 글자는 대문자로 한다. 카멜표기법
- _ 쓰는 것을 권하지 않는다.
<br/>

#### 상수
- 한번 `저장한 데이터 값이 바뀌지 않는 메모리 공간`을 말합니다.
- 변수처럼 데이터를 담을 순 있지만, 변수처럼 여러 값을 계속 변경해서 담을 수는 없습니다.
- [`final`]()키워드를 사용해서 대문자로만 구성된 명사로 정한다.
- 여러 단어로 구성된 이름의 경우 단어 사이 _써서 구분한다.
<br/>

#### 기본형
- 기본 자료형
<br/>

#### 기본형 사용 방법
- long 형: 데이터 뒤에 L을 붙여야 합니다.
- float 형 : 데이터 뒤에 F를 붙여야 합니다.
<br/>

#### 리터럴(Literal)
- 리터럴은 일종의 값, 어떤 특정한 값 자체라고 생각하면 됩니다.
<br/>

#### 기본형 형변환
- 묵시적 형변환(암묵적 형변환)
  - 작은 자료형을 더 큰 자료형으로 바꿀 때는 묵시적으로 형이 바뀝니다.


- 명시적 형변환(강제 형변환)
  - 큰 자료형을 작은 자료형으로 바꿀 때는 명시적으로 형을 바꿔줍니다.
    ```java
    예시) long x = 5000;
          Int y = (int) x;
    ```

<br/>

#### 산술연산자
- 부호 연산자(+,-)
- 증감 연산자(++,—)
- 산술 연잔자(+, -, *,/ , %)
<br/>

#### 비교연산자
- 같다 ==
- 다르다 !=
- 크다 >
- 작다 <
- 크거나 같다 >=
- 작거나 같다 <=
<br/>

#### 연산자 우선순위
- 0 : 최우선 순위 | . [] ()
- 1 : 단항 연산자 | ++ — ! ~ +/-
- 2 : 산술 연산자 * / % + -
- 3 : 시프트 연산자 >> << >>>
- 4 : 비교 연산자 > < >= <= == !=
- 5 : 비트 연산자 & | ^ ~
- 6 : 논리 연산자 && ||
- 7 : 삼항 연산자 조건식? A : B
- 8 : 대입 연산자 = *= /= %= += -=
<br/>

#### 후위 연산자
- 후위 연산자는 단항 연산자이긴 하지만, `다른 연산을 먼저 수행`하고 그 다음에 1을 증가시킵니다.
<br/>


## 📍 3부) 제어문

#### 제어문 키워드
- if, switch, for, for each, while, do while
<br/>

#### for과 for each 차이?
- for()은 배열의 길이만큼 순회하여 index를 통하여 배열의 각 원소들을 출력합니다.
- for each()은 배열을 순회하면서 배열의 각 원소들을 출력합니다.
<br/>

#### do while
- while문의 조건을 만족할 때까지 do 블럭을 반복하는 것
<br/>


## 📍 4부) 배열

#### 배열(array)
- 값이 여러 개 이지만 하나의 변수에 같은 데이터형으로 담겨져 있는 것.
- 배열은 기본 자료형이 아니고 `참조 자료형`입니다.
<br/>

#### 인덱스(index)
- 배열 변수는 전체를 가르키기 때문에 저장공간이 여러 개인 배열 안에 값을 하나씩 접근할 때는 인덱스를 이용하여 번호가 붙여진 배열 공간을 통해서 값을 가리키는 지 알 수 있습니다.
<br/>

#### for each문
- 자료구조 중에 순서가 없는 자료구조는 index가 없으므로 인덱스를 이용해서 값을 꺼내오는 일련의 동작을 자동으로 수행하므로 간편하게 데이터의 값을 접근할 수 있습니다.
- 자바 1.5 버전부터 for each문을 추가했고 다른언어에서도 for each 용어를 사용하기 때문에 자바에서도 해당 용어로 사용한다.
<br/>


## 📍 5부) 클래스와 객체

#### 클래스
- 객체를 만들기 위한 설계도입니다.
<br/>

#### 객체
- 클래스를 이용해 만들어낸 실체입니다.
<br/>

#### 인스턴스
- 메모리에 올라간(할당된) 클래스입니다. ([`new`]()라는 키워드는 클래스를 메모리에 올리라는 뜻)
- 클래스라는 설계도에 따라 소프트웨어 세상에 구현된 실체
- 개념적으로는 객체에 포함된다 볼 수 있습니다.
<br/>

#### 인스턴스화
- 클래스를 메모리에 올려 인스턴스 만드는 과정을 말합니다.
<br/>

#### 참조형
- 기본형을 제외한 모든 형. 배열, 클래스도 참조형입니다.
- new 키워드는 클래스를 메모리에 올리고, 메모리에 올라간 클래스를 인스턴스라고 부릅니다.
- 메모리에 올라간 인스턴스를 가리키는 변수, 참조하는 변수, 래퍼런스 변수 str입니다.
- str변수는 메모리의 위치 값을 저장하고 있습니다.
<br/>

#### 메모리 영역 비교

```java
예시) String a = “hello”
      String b = “hello”
```    
- a,b는 같은 인스턴스를 가리킨다. 문자열은 메모리 중에 상수들을 저장하는 영역에 저장하고, 해당 상수 영역에 같은 값이 있는 지 확인 후 있으면 새로 만들지 않고 가리킵니다.

```java
예시) String str = new String(“hello”)
```
- new 키워드로 인스턴스를 만들면 상수 영역을 참조 하지 않고 무조건 힙(heap) 메모리 영역에 생성합니다.
- [JVM 메모리 사용 영역(Runtime Data Area)](https://github.com/yungenie/java-concept-summary/blob/main/%5Bjava%5D%20JVM%20%EB%A9%94%EB%AA%A8%EB%A6%AC%20%EC%82%AC%EC%9A%A9%20%EC%98%81%EC%97%AD.md)
<br/>

#### :warning: 힙(heap) 메모리 영역
- 할당해야 할 메모리 크기를 프로그램을 실행하는 동안 결정해야 하는 경우 사용되는 공간.
<br/>

#### 메모리 영역 주소 비교
- 비교연산자 == 을 사용해서 메모리 영역의 주소가 같은 지 비교할 수 있다.
<br/>

#### String 클래스
- 불변 클래스로, String 반환하는 메서드는 모두 새로운 String을 생성해 반환한다. 그러므로 메소드를 호출해도 내부의 값이 변하지 않는다.
<br/>

#### 메소드 매개변수
- 매개변수를 파라미터(parameter)
- 전달된 인자를 받아들이는 변수
<br/>

#### 인자
- 아규먼트(argument)라 부르며 어떤 함수를 호출할 때 전달되는 값 자체를 의미합니다.
<br/>

#### 변수의 스코프(Scope) [변수에 접근할 수 있는 범위]
- 클래스 변수 : static키워드가 붙은 변수를 의미하며, 클래스를 생성하지 않아도 실행파일이 메모리에 로드될 때 생성합니다.
  즉, 프로그램을 시작할 때 생성했다가 프로그램이 종료될 때 소멸됩니다.
- 인스턴스 변수 : 클래스의 멤버로 설정하는 변수를 의미하며, new연산자를 이용하여 객체를 생성할 때 생성했다가 객체가 소멸할 때 소멸합니다.
- 지역 변수 : 클래스에 포함된 메소드에서 사용하는 변수로, 메소드를 사용 할 때 생성했다가 메소드가 종료될 때 소멸됩니다.
<br/>

#### static 필드
- static 키워드가 붙은 필드는 메모리 공간을 하나만 가지므로 모두 공유합니다.
- static한 필드는 객체를 생성하지 않고도 사용할 수 있다.
<br/>

#### 열거형
- 열거형은 서로 관련 있는 상수들을 모아서 집합으로 정의한 것입니다.
- 열거형은 JDK 5에서 추가된 문법입니다.
<br/>

#### enum
- enum 클래스명 { 세부항목(대문자) }
- 특정한 값만 사용할 때
<br/>


## 📍 6부) 클래스 다듬기

#### 생성자
- 생성자는 메서드와 비슷하게 생겼지만 생성자만의 특징이 있습니다.
- 메서드와 다르게 `return 리턴형을 갖고 있지 않습니다.`
- 생성자는 객체가 만들어질 때 필드를 초기화 하는 역할을 수행한다.
- 프로그래머가 생성자를 만들지 않으면 컴파일러가 매개변수가 없는 생성자, 즉, 기본 생성자를 자동으로 만든다.
- 하지만, 생성자를 하나라도 정의하면 기본 생성자가 자동으로 만들어지지 않습니다.
- 쉽게 설명해서, 필드의 초기값을 줘서 객체를 생성 할 수 있게 해준다.
<br/>

#### This
- 객체 자신을 참조하는 키워드로 내 구성 요소라는 의미를 지니고 있다.
- 같은 이름의 변수가 여러 개 있을 때 컴파일러가 헷갈린다. 매개변수인가 전역변수인지 등(this키워드를 사용하여 객체 필드라는 것을 알려줌)
- this는 해당 객체를 의미한다.
<br/>

#### 메소드 오버로딩
- 매개변수의 개수나 자료형이 다르면 같은 이름으로 메서드를 정의해서 사용할 수 있습니다.
- 대표적인 예인 system.out.println()의 println()메서드를 살펴보면 다양한 형식으로 오버로딩 되었기 때문에 어떤 자료형이든 출력 할 수 있다.
<br/>

#### 생성자 오버로딩
- 생성자도 메서드와 마찬가지로 여러 개를 선언할 수 있습니다.
- 매개변수의 수와 형만 다르면 생성자를 여러 개 선언할 수 있습니다.
<br/>

#### 생성자 오버로딩의 this
- this에 괄호를 붙이면 자기 자신의 생성자를 의미합니다.
- this()는 생성자 내에서 해당 클래스의 다른 생성자를 호출합니다.
- 코드가 중복되는 것을 방지할 수 있습니다.
<br/>

#### 패키지
- 관련한 클래스들을 폴더별로 관리하기 위함.
- 패키지명은 보통 도메인명을 거꾸로 적은 후 프로젝트명을 붙여서 사용합니다.
- import 단축키 : ctrl + shift + o
- 클래스명 대신 *(별표)를 사용해 해당 패키지 안에 있는 모든 클래스를 다 사용하겠다고 컴파일러와 jvm에 알려줘야 한다.
- import를 사용하지 않으면 클래스를 쓸 때마다 클래스 앞에 일일이 패키지명을 붙여줘야 한다.
- 즉, import 키워드를 사용해 다른 패키지에 들어 있는 클래스를 사용할 수 있다.
<br/>

## 📍 7부) 상속

#### 상속
- 종속되어 있는 관계를 is a 또는 kind of관계라고 말합니다.
- 부모가 자신이 가진 것을 자식에게 물려주는 것으로, extends라는 키워드와 클래스명을 사용하면 부모 클래스가 가진 것을 상속받을 수 있다.

  ```java
  public class 클래스명(자식) extends 클래스명(부모)
  ```    
- 단, 부모 클래스가 자식 클래스의 메서드를 사용할 수는 없습니다.
<br/>

#### 클래스
- 필드와 메서드를 가집니다.
<br/>

#### 접근제한자
- 관련 내용을 모아서 가지는 것을 캡슐화(encapsulation)
- 캡슐화된 필드와 메서드 중에서는 외부에 노출하지 않고 감추고 싶은 속성이나 메소드가 있을 때 접근제한자를 사용함.
- public : 어떤 클래스든 접근할 수 있다. 가장 넓은 의미에서 전체 공개라고 생각하면 됩니다.
- protected : 같은 패키지인 경우만 접근을 허용한다. 단, 다른 패키지라도 상속받은 자식 클래스에서는 접근 가능합니다.
- default : 자기 자신, 자기 자신과 같은 패키지 안에서 접근 허용
- private : 자기 자신만 접근할 수 있습니다.
- 접근 제한자의 범위 순서 : [`public > protected > default > private`]()
- 접근 제한자는 클래스, 메서드, 필드 앞에 붙여 사용가능하며 접근 제한자에 따라 어느까지 접근해 사용할 수 있게 할 것인지 정의할 수 있음.
<br/>

#### 추상 클래스
- 추상 클래스는 클래스 앞에 abstract 키워드를 넣어 정의한다.
- 추상 클래스는 미완성 추상 메소드를 포함할 수 있다.
- 추상 메소드란 내용이 없는 메서드다. 즉, 구현되지 않은 메서드다.
- 추상 메서드는 리턴형 앞에 abstract 키워드를 붙여야 한다.
- 추상 클래스는 객체를 생성할 수 없다.
- 단, 추상 클래스를 상속한 클래스는 추상 클래스가 가진 추상 메소드를 반드시 구현해야 합니다.
- 하나라도 구현하지 않으면 그 클래스도 추상 클래스가 됩니다.
- 메서드 안에 아무런 내용이 없더라도 {} 중괄호를 열고 닫으면 컴파일러는 메서드를 구현했다고 판단합니다.
<br/>

#### Super
- 부모클래스를 상속받아 객체를 만들 때
- new라는 키워드로 객체를 생성하면 자식클래스가 메모리에 올라갈때, 즉 인스턴스화될때 부모 클래스 객체도 인스턴스화 됩니다.
- 부모 클래스 객체가 먼저 생성돼야만 자식클래스 객체도 생성된다.
- 부모의 생성자를 호출하지 않으면 컴파일러는 기본 생성자만 호출합니다. 그런데 부모 클래스에서 기본 생성자가 없고 다른 생성자가 있으면 super라는키워드를 사용해서 호출해야 에러 발생이 안난다.
<br/>

#### 오버라이딩
- 부모가 물려준 메소드를 자식 클래스에서 재정의해 사용하는 것. (부모가 물려준 기능이 나에게 필요하지만 별로 좋지 않고 수정하고 싶은 경우)
- 메서드를 오버라이드하면 무조건 자식의 메서드를 이용해야 한다.
- 하지만, 부모가 구현한 메소드를 실행하고 싶을 때는 명시적으로 부모 클래스를 지칭하는 super() 키워드를 통해 super.메서드, super.필드 등을 호출할 수 있다.
<br/>

#### 클래스 형변환
- 부모 타입으로 자식을 가리킬 수는 있지만 부모타입으로 자식을 가리켰을 때는 부모가 가진 메서드만 사용할 수 있습니다. (묵시적,암묵적 형변환)
- 명시적 형변환 자식클래스 변수 = (자식클래스) 부모클래스 > 형변환으로 객체가 가진 모든 부분을 사용한다는 것.
<br/>


## 📍 8부) 인터페이스와 다른 형식의 클래스

#### 인터페이스 정의
- 인터페이스 자체가 구현이 없고, 기능(메소드)을 선언만 하는 것이다.
- 인터페이스 자체로 객체를 생성하지 못합니다. 다른 클래스에서 인터페이스를 구현하여 타입의 역할로는 가능하다.
- `인터페이스에 선언한 변수는 무조건 상수로 처리`됩니다. 이렇게 선언한 변수는 실행 중에 값을 바꿀 수 없습니다. ( final 키워드 없어도 상수처럼 사용 가능)
<br/>

#### 인터페이스 default 메서드
- 자바8부터는 default메서드와 static메서드를 정의할 수 있음.
- 구현한 클래스에서는 default메서드를 오버라이딩할 수도 있음.
- 자바8에서 왜 default 메서드를 추가했을까요?
  - 인터페이스가 변경될 때 인터페이스를 구현한 모든 클래스가 다시 변경사항을 구현해야하기 때문에 이런 문제를 해결하기 위해 인터페이스에서 메소드를 구현할 수 있도록 default를 추가한 것입니다.
- 인터페이스에서 구현한 static메소드를 인터페이스를 구현한 클래스에서 접근할때 인터페이스명.메서드명(); 형식으로 호출 가능합니다. (객체 생성 안하고 호출 가능)
<br/>

#### 내부 클래스
- 특정 클래스 내에서만 사용하는 클래스를 내부 클래스로 선언합니다.
- 인스턴스 클래스(instance class) : 중첩 클래스 혹은 인스턴스 클래스(클래스 안에 클래스)
  ```
    해당클래스 해당인스턴스변수 = new 해당 클래스 ();
    해당클래스.내부클래스 해당내부클래스변수 = 인스턴스 변수.new 내부 클래스()
  ```  
- 스태틱 클래스(static class) : 정적 중첩 클래스 또는 static 클래스
  ```
    해당클래스.내부스태틱클래스 해당내부스태틱클래스변수 = new 해당클래스.내부스태틱클래스();
  ```
- 지역 클래스(local class) : 중첩 클래스 또는 지역 클래스라는 내부 클래스입니다.
  메서드 안에 클래스가 있는 경우로 메소드 안에 클래스를 선언하고, 클래스에 대한 객체를 선언해서 원하는 값을 출력할 수 있게 구현한다.
  ```
  해당클래스 해당클래스변수 = new 해당클래스();
  해당클래스변수.메소드();
  ```
- 익명클래스(anonymous class) : 추상클래스의 객체를 만들고 생성자 다음에 중괄호를 여닫아 오버라이딩해서 구현 가능.
  클래스를 상속받는 이름 없는 객체를 만들기 위해. 이유는? 상속받는 클래스를 정의하지 않고 일회성으로 바로 사용하는 편리함때문이다.
<br/>


## 📍 9부) 예외처리

#### Exception
- 프로그램 실행하는 과정에서 발생하는 예기치 못한 사건을 예외(Exception)라고 합니다.

- 컴파일 오류랑 예외 차이?
  컴파일 오류는 문법에 맞지 않아 발생하는 오류 입니다. 예외는 실행 시점에서 잘못된 값으로 발생하거나 여러 상황에서 발생하는 예기치 못한 사건을 말합니다.
  
- 예외 처리 시 try-catch-finally문을 사용함.
  ```java
    try{
    수행할 코드, 예외 발생 가능성이 있는 블록
    } catch(발생 할 수 있는 예외 타입 변수명){
    예외 처리 블록
    } finally { (finally 생략 가능)
    예외 발생 여부와 상관없이 무조건 실행하는 블록
    }
  ```  
- catch문에서 toString() 메서드는 예외 정보를 알려줍니다. 또한, catch블록은 여러 개 사용할 수 있다.
- catch블록의 발생 가능 예외 클래스에 Exception이라고 두면 어떤 예외가 발생해도 하나의 catch블록으로 모든 예외를 처리할 수 있습니다.
- *모든 예외 객체는 Exception클래스를 상속 받습니다.
<br/>

#### Throws
- 발생 시점에서 처리하지 않고 호출된 쪽에서 처리하라고 넘길 수 있는 키워드가 Throws입니다.
- Throws 발생오류1, 발생오류 2…Exception{} Exception이라고 넘겨주면 모든 예외를 넘길 수 있습니다.
<br/>

#### Exception발생시키기
- 직접 오류를 발생시키는 방법. Throws new 예외타입
<br/>

#### 사용자 정의 Exception
- 사용자가 직접 Exception을 상속받아 정의해 사용할 수 있습니다.
- Exception을 상속받은 클래스를 `Checked Exception`이라고 합니다. 에러 처리를 하지 않으면 컴파일 에러가 발생하기 때문에 반드시 에러를 처리해야 합니다.
- `RuntimeException`을 상속 받아 정의한 Exception은 에러를 처리 하지 않아도 컴파일 일상에서 에러를 발생시키지는 않습니다.
<br/>



